<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="utf-8">
  <link href="webrtc.css" rel="stylesheet">
  <title>QUIC API for WebRTC</title>
  <script class="remove" src="respec-w3c-common.js" type="text/javascript"></script>
  <script src="respec-config.js" class="remove"></script>
</head>
<body>
  <section id="abstract">
    <p>This document defines a set of ECMAScript APIs in WebIDL to allow data to be sent
    and received from another browser or device implementing the QUIC
    protocol. This specification is being developed in conjunction with a protocol
    specification developed by the IETF QUIC Working Group.</p>
  </section>
  <section id="sotd">
    <p>The API is based on preliminary work done in the W3C ORTC Community Group.</p>
  </section>
  <section class="informative" id="intro">
    <h2>Introduction</h2>
    <p>This specification extends the WebRTC specification [[!WEBRTC]] to
    enable the use of QUIC [[!QUIC-TRANSPORT]] to exchange arbitrary data with
    remote peers using NAT-traversal technologies such as ICE, STUN, and
    TURN. Since QUIC can be multiplexed on the same port as RTP, RTCP,
    DTLS, STUN and TURN, this specification is compatible with all the
    functionality defined in [[!WEBRTC]], including communication
    using audio/video media and SCTP data channels.</p>
    <p>While this specification defines an interface to QUIC streams,
    by utilizing a QUIC stream per message, it is possible to implement
    support for message-based communications (such as <code>RTCDataChannel</code>)
    on top.  While the QUIC transport defined in [[!QUIC-TRANSPORT]] is reliable,
    support for unreliable communications is achievable via use of timers or
    through future extensions to the QUIC protocol.</p>
  </section>
  <section id="conformance">
    <p>This specification defines conformance criteria that apply to a single
    product: the <dfn>user agent</dfn> that implements the interfaces that it
    contains.</p>
    <p>Conformance requirements phrased as algorithms or specific steps may be
    implemented in any manner, so long as the end result is equivalent. (In
    particular, the algorithms defined in this specification are intended to be
    easy to follow, and not intended to be performant.)</p>
    <p>Implementations that use ECMAScript to implement the APIs defined in
    this specification <em class="rfc2119" title="MUST">MUST</em> implement them
    in a manner consistent with the ECMAScript Bindings defined in the Web IDL
    specification [[!WEBIDL-1]], as this specification uses that specification
    and terminology.</p>
  </section>
  <section>
    <h2>Terminology</h2>
     <p>The <code><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#eventhandler">EventHandler</a></code>
      interface, representing a callback used for event handlers, and the <a href=
      "http://dev.w3.org/html5/spec/webappapis.html#errorevent"><code><dfn>ErrorEvent</dfn></code></a>
      interface are defined in [[!HTML51]].</p>
      <p>The concepts <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#queue-a-task">queue a task</a></dfn>,
      <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#fire-a-simple-event">fires a simple
      event</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#networking-task-source">networking
      task source</a></dfn> are defined in [[!HTML51]].</p>
      <p>The term <dfn>finished reading</dfn> means that the application has read all
      available data up to the STREAM frame with the FIN bit set, which causes
      the <a>[[\Readable]]</a> slot to be set to <code>false</code>.</p> 
      <p>The terms <dfn>event</dfn>, <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handlers">event
      handlers</a></dfn> and <dfn><a href=
      "http://dev.w3.org/html5/spec/webappapis.html#event-handler-event-type">event
      handler event types</a></dfn> are defined in [[!HTML51]].</p>
     <p>When referring to exceptions, the terms <dfn><a
      href="https://www.w3.org/TR/WebIDL-1/#dfn-throw">throw</a></dfn> and
      <dfn data-dfn-for="exception"><a href=
      "https://www.w3.org/TR/WebIDL-1/#dfn-create-exception">create</a></dfn> are
      defined in [[!WEBIDL-1]].</p>
      <p>The terms <dfn data-lt="fulfill|fulfillment">fulfilled</dfn>, <dfn
      data-lt="reject|rejection|rejecting|rejected">rejected</dfn>,
      <dfn data-lt="resolve|resolves">resolved</dfn>, <dfn>pending</dfn> and
      <dfn data-lt="settled">settled</dfn> used in the context of Promises are defined in
      [[!ECMASCRIPT-6.0]].</p>
      <p>The <dfn><code>RTCIceTransport</code></dfn> and <dfn><code>RTCCertificate</code></dfn> interfaces
      and the <dfn><code>RTCDtlsFingerprint</code></dfn> dictionary are defined in [[!WEBRTC]].</p>
  </section>
  <section id="quic-transport*">
    <h2><dfn>RTCQuicTransport</dfn> Interface</h2>
    <p>The <code>RTCQuicTransport</code> includes information relating
    to QUIC transport.</p>
    <section id="rtcquictransport-overview*">
      <h3>Overview</h3>
      <p>An <code><a>RTCQuicTransport</a></code> instance can be associated to
      one or more <code><a>RTCQuicBidirectionalStream</a></code>,
      <code><a>RTCQuicSendStream</a></code>, or <code><a>RTCQuicReceiveStream</a></code>
      instances.</p>
      <p class="note">The QUIC API presented in this and the subsequent
      section represents a preliminary proposal based on work-in-progress
      within the IETF QUIC WG. Since the QUIC transport specification is
      a work-in-progress, both the protocol and API are likely to
      change significantly going forward.</p>
    </section>
    <section id="rtcquictransport-operation*">
      <h3>Operation</h3>
      <p>The QUIC transport protocol is described in [[!QUIC-TRANSPORT]].
      A <code><a>RTCQuicTransport</a></code> instance is constructed
      using an <code><a>RTCIceTransport</a></code> and an optional sequence of
      <code><a>RTCCertificate</a></code> objects.
      An <code><a>RTCQuicTransport</a></code> object in the <code>"closed"</code> or
      <code>"failed"</code> states can be garbage-collected when it is no longer
      referenced.</p>
      <p>The QUIC negotiation occurs between transport endpoints determined via ICE.
      Multiplexing of QUIC with STUN, TURN, DTLS, RTP and RTCP
      is supported within [[QUIC-TRANSPORT]].</p>
      <p>A newly constructed <code><a>RTCQuicTransport</a></code> <em class="rfc2119"
      title="MUST">MUST</em> listen and respond to incoming QUIC packets before
      <code>start()</code> is called. However, to complete the negotiation it is
      necessary to verify the remote fingerprint by computing fingerprints for
      the selected remote certificate using the digest algorithms provided
      in <code><var>remoteParameters</var>.fingerprints[].algorithm</code>. If a
      calculated fingerprint and algorithm matches a fingerprint and algorithm
      included in <code><var>remoteParameters</var>.fingerprints[]</code>,
      the remote fingerprint is verified. After the QUIC handshake exchange
      completes (but before the remote fingerprint is verified) incoming media packets
      may be received. A modest buffer <em class="rfc2119" title="MUST">MUST</em> be
      provided to avoid loss of media prior to remote fingerprint validation (which can
      begin after <code>start()</code> is called).</p>
    </section>
    <section id="rtcquictransport-interface-definition*">
      <h3>Interface Definition</h3>
      <div>
        <pre class="idl">
        [ Constructor (RTCIceTransport transport, optional sequence&lt;RTCCertificate&gt; certificates), Exposed=Window]
interface RTCQuicTransport : RTCStatsProvider {
    readonly        attribute RTCIceTransport          transport;
    readonly        attribute RTCQuicTransportState    state;
    RTCQuicParameters     getLocalParameters ();
    RTCQuicParameters?    getRemoteParameters ();
    sequence&lt;RTCCertificate&gt; getCertificates ();
    sequence&lt;ArrayBuffer&gt; getRemoteCertificates ();
    void                  start (RTCQuicParameters remoteParameters);
    void                  stop ();
    RTCQuicBidirectionalStream         createBidirectionalStream ();
    RTCQuicSendStream                  createSendStream ();
                    attribute EventHandler             onstatechange;
                    attribute EventHandler             onerror;
                    attribute EventHandler             onreceivestreamwithdata;
                    attribute EventHandler             onbidirectionalstreamwithdata;
};</pre>
        <section>
          <h2>Constructors</h2>
          When the <code><a>RTCQuicTransport</a></code> constructor is invoked,
          the user agent <em class="rfc2119" title="MUST">MUST</em> run the
          following steps:
          <ol>
            <li>Let <var>transport</var> be the first argument.</li>
            <li>If <var>transport</var> is in the <code>"closed"</code>
            state, <a>throw</a> an <code>InvalidStateError</code> and abort
            these steps.</li>
            <li>If <var>transport</var> has been used to construct another
            <code><a>RTCQuicTransport</a></code> whose <a>[[\QuicTransportState]]</a> slot
            is not <code>"closed"</code>, <a>throw</a> an <code>InvalidStateError</code>
            and abort these steps.</li>
            <li>
              Let <var>certificates</var> be the second argument if provided,
              <code>null</code> otherwise.
            </li>
            <li>
              If <var>certificates</var> is non-null and is non-empty, check that the
              <code>expires</code> attribute of each <code><a>RTCCertificate</a></code>
              object is in the future. If a certificate has expired, <a>throw</a> an
              <code>InvalidAccessError</code> and abort these steps.
            </li>
            <li>
              Let <var>quictransport</var> be a newly constructed
              <code><a>RTCQuicTransport</a></code> object.
            </li>
            <li>Let <var>quictransport</var> have a <dfn>[[\QuicTransportWritableStreams]]</dfn>
            internal slot representing a sequence of <code><a>RTCQuicWritableStream</a></code>
            objects, initialized to empty.
            </li>
            <li>Let <var>quictransport</var> have a <dfn>[[\QuicTransportReadableStreams]]</dfn>
            internal slot representing a sequence of <code><a>RTCQuicReadableStream</a></code>
            objects, initialized to empty.
            </li>
            <li>
              Let <var>quictransport</var> have a <dfn>[[\QuicTransportState]]</dfn>
              internal slot, initialized to <code>"new"</code>.
            </li>
            <li>
              Let <var>quictransport</var> have a <dfn>[[\Certificates]]</dfn>
              internal slot.
            </li>
            <li>
              If <var>certificates</var> is non-null and is non-empty,
              initialize the <a>[[\Certificates]]</a> internal slot to
              <var>certificates</var>.
            </li>
            <li>
              If <var>certificates</var> is <code>null</code> or is empty,
              generate a certificate using the default key generation algorithm
              and store it in the <a>[[\Certificates]]</a> internal slot.
            </li> 
            <li>
              Return <var>quictransport</var>.
            </li>
          </ol>          
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "constructors">
            <dt><code><a>RTCQuicTransport</a></code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">transport</td>
                    <td class="prmType"><code><a>RTCIceTransport</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">certificates</td>
                    <td class="prmType">
                    <code>sequence</code>&lt;<code><a>RTCCertificate</a></code>&gt;</td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptTrue"><span role="img" aria-label=
                    "True">&#10004;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "attributes">
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCIceTransport</a></span>, readonly</dt>
            <dd>
              <p>The associated <code><a>RTCIceTransport</a></code> instance.</p>
            </dd>
            <dt><dfn><code>state</code></dfn> of type <span class=
            "idlAttrType"><a>RTCQuicTransportState</a></span>, readonly</dt>
            <dd>
              <p>The current state of the QUIC transport. On getting, it
              <em class="rfc2119" title="MUST">MUST</em> return the value
              of the <a>[[\QuicTransportState]]</a> internal slot.</p>
            </dd>
            <dt><dfn><code>onstatechange</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>statechange</a></code>, <em class="rfc2119" title="MUST">MUST</em>
              be fired any time the <a>[[\QuicTransportState]]</a> slot changes.</p>
            </dd>
            <dt><dfn><code>onerror</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type <code>error</code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on reception of a QUIC
              error; an implementation <em class="rfc2119" title=
              "SHOULD">SHOULD</em> include QUIC error information in
              <var>error.message</var> (defined in [[!HTML51]] Section 7.1.3.8.2).</p>
            </dd>
            <dt><dfn><code>onreceivestreamwithdata</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>receivestreamwithdata</a></code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on when data is received
              from a newly created remote <code><a>RTCQuicSendStream</a></code> for the
              first time.
              </p>
            </dd>
            <dt><dfn><code>onbidirectionalstreamwithdata</code></dfn> of type <span class=
            "idlAttrType"><a>EventHandler</a></span></dt>
            <dd>
              <p>This event handler, of event handler event type
              <code><a>bidirectionalstreamwithdata</a></code>,
              <em class="rfc2119" title="MUST">MUST</em> be fired on when when data is received
              from a newly created remote <code><a>RTCQuicBidirectionalStream</a></code> for the
              first time.
              </p>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicTransport" data-dfn-for="RTCQuicTransport" class=
          "methods">
            <dt><code>getLocalParameters</code></dt>
            <dd>
              <p><dfn>getLocalParameters()</dfn> obtains the QUIC parameters of
              the local <code><a>RTCQuicTransport</a></code> upon construction.
              If multiple certificates were provided in the constructor, then
              multiple fingerprints will be returned, one for each certificate.
              <code>getLocalParameters().role</code> always returns the default
              role of a newly constructed <code><a>RTCQuicTransport</a></code>;
              for a browser this will be <code>auto</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicParameters</a></code>
              </div>
            </dd>
            <dt><code>getRemoteParameters</code></dt>
            <dd>
              <p><dfn>getRemoteParameters()</dfn> obtains
              the remote QUIC parameters passed in the
              <code>start()</code> method. Prior to calling
              <code>start()</code>, null is returned.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicParameters</a></code>, nullable
              </div>
            </dd>
            <dt><code>getCertificates</code></dt>
            <dd>
              <p><dfn>getCertificates()</dfn> returns the value of the <code><a>RTCQuicTransport</a></code>'s
              <a>[[\Certificates]]></a> internal slot.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;RTCCertificate&gt;</code>
              </div>
            </dd>
            <dt><code>getRemoteCertificates</code></dt>
            <dd>
              <p><dfn>getRemoteCertificates()</dfn> returns the certificate chain in use by the remote side, with each
              certificate encoded in binary Distinguished Encoding Rules (DER) [[!X690]].
              <code><a>getRemoteCertificates()</a></code> returns an empty list prior to
              selection of the remote certificate, which is completed once
              <code><a>RTCQuicTransportState</a></code> transitions to
              <code>connected</code>.</p>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>sequence&lt;ArrayBuffer&gt;</code>
              </div>
            </dd>
            <dt><dfn><code>start</code></dfn></dt>
            <dd>
              <p>Start QUIC transport negotiation with the parameters of the remote QUIC
              transport, including verification of the remote fingerprint.
              Only a single QUIC transport can be multiplexed over an ICE transport.
              Therefore if a <code><a>RTCQuicTransport</a></code> object
              <var>quicTransportB</var> is constructed with an
              <code><a>RTCIceTransport</a></code> object <var>iceTransport</var>
              previously used to construct another <code><a>RTCQuicTransport</a></code>
              object <var>quicTransportA</var>, then if
              <code>quicTransportB.start()</code> is called prior to having called
              <code>quicTransportA.stop()</code>, then <a>throw</a> an
              <code>InvalidStateError</code>.</p>
              <p>If <code>start</code> is called after a previous <code>start</code>
              call, or if <code>state</code> is <code>closed</code>, <a>throw</a>
              an <code>InvalidStateError</code>.</p>
              <p>If all of the values of
              <code><var>remoteParameters</var>.fingerprints[<var>j</var>].algorithm</code>
              are unsupported, where <var>j</var> goes from 0 to the number of fingerprints,
              <a>throw</a> a <code>NotSupportedError</code>.</p>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">remoteParameters</td>
                    <td class="prmType"><code><a>RTCQuicParameters</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>stop</code></dfn></dt>
            <dd>
              <p>Stops and closes the <code><a>RTCQuicTransport</a></code> object.
              This triggers an "Immediate Close," as described in [[QUIC-TRANSPORT]] section 6.13.3.
              <p>When <code>stop</code> is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>
                on which <code>stop</code> is invoked.</li>
                <li>If <var>transport</var>'s <a>[[\QuicTransportState]]</a> is <code>"closed"</code>
                then abort these steps.</li>
                <li>Set <var>transport</var>'s <a>[[\QuicTransportState]]</a> to
                <code>"closed"</code>.</li>
                <li>Start the "Immediate Close" procedure by sending an APPLICATION_CLOSE frame.</li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
           <dt><dfn><code>createBidirectionalStream</code></dfn></dt>
            <dd>
              <p>Creates an <code><a>RTCQuicBidirectionalStream</a></code> object.
              Since [[QUIC-TRANSPORT]] only defines reliable QUIC streams,
              <code>createBidectionalStream</code> only supports creation of reliable
              streams.</p>
              <p>When <code>createBidectionalStream</code> is called, the user agent
              <em class="rfc2119" title="MUST">MUST</em> run the following
              steps:</p>
              <ol>
                <li>
                  <p>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>
                  on which <code>createBidectionalStream</code> is invoked.</p>
                </li>
                <li>
                  <p>If <code><var>transport</var>'s state</code> is not <code>connected</code>
                  <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> be a newly created
                  <code><a>RTCQuicBidirectionalStream</a></code> object.</p>
                </li>
                <li>
                  <p>Add <var>stream</var> to <var>transport</var>'s
                  <a>[[\QuicTransportWritableStreams]]</a> internal slot. </p>
                </li>
                <li>
                  <p>Add <var>stream</var> to <var>transport</var>'s
                  <a>[[\QuicTransportReadableStreams]]</a> internal slot. </p>
                </li>
                <li>
                  <p>Return <var>stream</var> and continue the following steps
                  in the background.</p>
                </li>
                <li>
                  <p>Create <var>stream</var>'s associated underlying data
                  transport.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicBidirectionalStream</a></code>
              </div>
            </dd>
           <dt><dfn><code>createSendStream</code></dfn></dt>
            <dd>
              <p>Creates an <code><a>RTCQuicSendStream</a></code> object.
              Since [[QUIC-TRANSPORT]] only defines reliable QUIC streams,
              <code>createSendStream</code> only supports creation of reliable
              streams.</p>
              <p>When <code>createSendStream</code> is called, the user agent
              <em class="rfc2119" title="MUST">MUST</em> run the following
              steps:</p>
              <ol>
                <li>
                  <p>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>
                  on which <code>createSendStream</code> is invoked.</p>
                </li>
                <li>
                  <p>If <code><var>transport</var>'s state</code> is not <code>connected</code>
                  <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</p>
                </li>
                <li>
                  <p>Let <var>stream</var> be a newly created
                  <code><a>RTCQuicSendStream</a></code> object.</p>
                </li>
                <li>
                  <p>Add <var>stream</var> to <var>transport</var>'s <a>[[\QuicTransportWritableStreams]]</a>
                  internal slot. </p>
                </li>
                <li>
                  <p>Return <var>stream</var> and continue the following steps
                  in the background.</p>
                </li>
                <li>
                  <p>Create <var>stream</var>'s associated underlying data
                  transport.</p>
                </li>
              </ol>
              <div>
                <em>No parameters.</em>
              </div>
              <div>
                <em>Return type:</em> <code><a>RTCQuicSendStream</a></code>
              </div>
            </dd>

          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicparameters*">
      <h3><dfn>RTCQuicParameters</dfn> Dictionary</h3>
      <p>The <code>RTCQuicParameters</code> dictionary includes information
      relating to QUIC configuration.</p>
      <div>
        <pre class="idl">dictionary RTCQuicParameters {
             RTCQuicRole                  role = "auto";
             sequence&lt;RTCDtlsFingerprint&gt; fingerprints;
};</pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCQuicParameters</a> Members</h2>
          <dl data-link-for="RTCQuicParameters" data-dfn-for="RTCQuicParameters" class=
          "dictionary-members">
            <dt><dfn><code>role</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicRole</a></span>, defaulting to
            <code>"auto"</code></dt>
            <dd>
              <p>The QUIC role, with a default of <code>auto</code>.</p>
            </dd>
            <dt><dfn><code>fingerprints</code></dfn> of type <span class=
            "idlMemberType">sequence&lt;<a>RTCDtlsFingerprint</a>&gt;</span></dt>
            <dd>
              <p>Sequence of fingerprints, at least one fingerprint for each certificate
              (with one computed with the digest algorithm used in the certificate
              signature).</p>
            </dd> 
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3><dfn>ReceiveStreamWithDataEvent</dfn></h3>
      <p>The <code><a>receivestreamwithdata</a></code> event uses the
      <code><a>ReceiveStreamWithDataEvent</a></code> interface.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, ReceiveStreamWithDataEventInit eventInitDict), Exposed=Window]
interface ReceiveStreamWithDataEvent : Event {
    readonly        attribute RTCQuicReceiveStream stream;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="ReceiveStreamWithDataEvent" data-dfn-for="ReceiveStreamWithDataEvent"
          class="constructors">
            <dt><code>ReceiveStreamWithDataEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>ReceiveStreamWithDataEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="ReceiveStreamWithDataEvent" data-dfn-for="ReceiveStreamWithDataEvent"
          class="attributes">
            <dt><code>stream</code> of type <span class=
            "idlAttrType"><a>RTCQuicReceiveStream</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-receivequicstreamevent-stream"><code>stream</code></dfn>
              attribute represents the <code><a>RTCQuicReceiveStream</a></code> object
              associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
          <p>The <dfn><code>ReceiveStreamWithDataEventInit</code></dfn> dictionary includes
          information on the configuration of the QUIC stream.</p>
        <pre class="idl">dictionary ReceiveStreamWithDataEventInit : EventInit {
             RTCQuicReceiveStream stream;
};</pre>
        <section>
          <h2>Dictionary ReceiveStreamWithDataEventInit Members</h2>
          <dl data-link-for="ReceiveStreamWithDataEventInit" data-dfn-for=
          "ReceiveStreamWithDataEventInit" class="dictionary-members">
            <dt><dfn><code>stream</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicReceiveStream</a></span></dt>
            <dd>
              <p>The <code><a>RTCQuicReceiveStream</a></code> object associated with the
              event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section>
      <h3><dfn>BidirectionalStreamWithDataEvent</dfn></h3>
      <p>The <code><a>bidirectionalstreamwithdata</a></code> event uses the
      <code><a>BidirectionalStreamWithDataEvent</a></code> interface.</p>
      <div>
        <pre class="idl">
        [ Constructor (DOMString type, BidirectionalStreamWithDataEventInit eventInitDict), Exposed=Window]
interface BidirectionalStreamWithDataEvent : Event {
    readonly        attribute RTCQuicBidirectionalStream stream;
};</pre>
        <section>
          <h2>Constructors</h2>
          <dl data-link-for="BidirectionalStreamWithDataEvent" data-dfn-for="BidirectionalStreamWithDataEvent"
          class="constructors">
            <dt><code>BidirectionalStreamWithDataEvent</code></dt>
            <dd>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">type</td>
                    <td class="prmType"><code>DOMString</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                  <tr>
                    <td class="prmName">eventInitDict</td>
                    <td class="prmType"><code><a>BidirectionalStreamWithDataEventInit</a></code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
            </dd>
          </dl>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="BidirectionalStreamWithDataEvent" data-dfn-for="BidirectionalStreamWithDataEvent"
          class="attributes">
            <dt><code>stream</code> of type <span class=
            "idlAttrType"><a>RTCQuicBidirectionalStream</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-bidirectionalquicstreamevent-stream"><code>stream</code></dfn>
              attribute represents the <code><a>RTCQuicBidirectionalStream</a></code> object
              associated with the event.</p>
            </dd>
          </dl>
        </section>
      </div>
      <div>
          <p>The <dfn><code>BidirectionalStreamWithDataEventInit</code></dfn> dictionary includes
          information on the configuration of the QUIC stream.</p>
        <pre class="idl">dictionary BidirectionalStreamWithDataEventInit : EventInit {
             RTCQuicBidirectionalStream stream;
};</pre>
        <section>
          <h2>Dictionary BidirectionalStreamWithDataEventInit Members</h2>
          <dl data-link-for="BidirectionalStreamWithDataEventInit" data-dfn-for=
          "BidirectionalStreamWithDataEventInit" class="dictionary-members">
            <dt><dfn><code>stream</code></dfn> of type <span class=
            "idlMemberType"><a>RTCQuicBidirectionalStream</a></span></dt>
            <dd>
              <p>The <code><a>RTCQuicBidirectionalStream</a></code> object associated with the
              event.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicrole*">
      <h3><dfn>RTCQuicRole</dfn> Enum</h3>
      <p><code>RTCQuicRole</code> indicates the role of the QUIC
      transport.</p>
      <div>
        <pre class="idl">enum RTCQuicRole {
    "auto",
    "client",
    "server"
};</pre>
        <table data-link-for="RTCQuicRole" data-dfn-for="RTCQuicRole" class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.auto">auto</code></dfn></td>
              <td>
                <p>The QUIC role is determined based on the resolved ICE role:
                the ICE <code>controlled</code> role acts as the QUIC client and
                the ICE <code>controlling</code> role acts as the QUIC server.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.client">client</code></dfn></td>
              <td>
                <p>The QUIC client role.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicRole.server">server</code></dfn></td>
              <td>
                <p>The QUIC server role.</p>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
    <section id="rtcquicroleinfo">
      <h3>QUIC role determination</h3>
      <p>To diagnose QUIC role issues, an application may wish to determine
      the desired and actual QUIC role of an <code><a>RTCQuicTransport</a></code>.
      For a browser implementing ORTC, a <code><a>RTCQuicTransport</a></code>
      object assumes a QUIC role of <code>auto</code> upon construction.
      This implies that the QUIC role is determined by the ICE role.  Since
      <code>getLocalParameters().role</code> always returns the role assigned
      to an <code><a>RTCQuicTransport</a></code> object upon construction
      (<code>auto</code> for a browser), the <code>getLocalParameters</code>
      method cannot be used to determine the desired or actual role of an
      <code><a>RTCQuicTransport</a></code>.</p>
      <p>An application can determine the
      desired role of an <code><a>RTCQuicTransport</a></code> from the value of
      <code><var>remoteParameters</var>.role</code> passed to
      <code><a>RTCQuicTransport</a>.start(<var>remoteParameters</var>)</code>.
      If <code><var>remoteParameters</var>.role</code> is <code>server</code>
      then the desired role of the <code><a>RTCQuicTransport</a></code>
      is <code>client</code>. If <code><var>remoteParameters</var>.role</code>
      is <code>client</code> then the desired role of the
      <code><a>RTCQuicTransport</a></code> is <code>server</code>.</p>
      <p>The <code>RTCQuicTransport.transport.onstatechange</code> EventHandler
      can be used to determine whether an <code><a>RTCQuicTransport</a></code>
      transitions to the desired role. When
      <code><a>RTCQuicTransport</a>.transport.state</code> transitions to
      <code>connected</code>, if <code><a>RTCQuicTransport</a>.transport.role</code>
      is <code>controlled</code> then the role of the
      <code><a>RTCQuicTransport</a></code> is <code>client</code>.
      If <code><a>RTCQuicTransport</a>.transport.role</code>
      is <code>controlling</code> then the role of the
      <code><a>RTCQuicTransport</a></code> is <code>server</code>.</p>
    </section>
    <section id="rtcquictransportstate*">
      <h3><dfn>RTCQuicTransportState</dfn> Enum</h3>
      <p><code>RTCQuicTransportState</code> indicates the state of the QUIC
      transport.</p>
      <div>
        <pre class="idl">enum RTCQuicTransportState {
    "new",
    "connecting",
    "connected",
    "closed",
    "failed"
};</pre>
        <table data-link-for="RTCQuicTransportState" data-dfn-for="RTCQuicTransportState"
        class="simple">
          <tbody>
            <tr>
              <th colspan="2">Enumeration description</th>
            </tr>
            <tr>
              <td><dfn><code id="idl-def-RTCQuicTransportState.new">new</code></dfn></td>
              <td>
                <p>The <code><a>RTCQuicTransport</a></code> object has been created and
                has not started negotiating yet.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.connecting">connecting</code></dfn></td>
              <td>
                <p>QUIC is in the process of negotiating a secure connection and
                verifying the remote fingerprint. Once a secure connection is negotiated
                (but prior to verification of the remote fingerprint, enabled by calling
                <code>start()</code>), incoming data can flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.connected">connected</code></dfn></td>
              <td>
                <p>QUIC has completed negotiation of a secure connection and verified the
                remote fingerprint. Outgoing data and media can now flow through.</p>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.closed">closed</code></dfn></td>
              <td>
                <p>The QUIC connection has been closed intentionally via a call to
                <code>stop()</code> or receipt of a closing frame as described in
                [[QUIC-TRANSPORT]]. When the <code><a>RTCQuicTransport</a></code>'s
                internal <a>[[\QuicTransportState]]</a> slot transitions to
                <code>closed</code> the user agent <em class="rfc2119" title="MUST">MUST</em>
                run the following steps:</p>
                <ol>
                  <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>.
                  <li>For each RTCQuicReadableStream in <var>transport</var>'s
                  <a>[[\QuicTransportReadableStreams]]</a> internal slot run the
                  following:</li>
                  <ol>
                    <li>Let <var>stream</var> be the RTCQuicReadableStream.</li>
                    <li>Set <var>stream</var>'s <a>[[\Readable]]</a> slot to
                    <code>false</code>.</li>
                    <li>Clear the <var>stream</var>'s read buffer.</li>
                    <li>Remove the <var>stream</var> from the <var>transport</var>'s
                    <a>[[\QuicTransportReadableStreams]]</a> internal slot.
                  </ol>
                  <li>For each RTCQuicWritableStream in <var>transport</var>'s
                  <a>[[\QuicTransportWritableStreams]]</a> internal slot run the
                  following:</li>
                  <ol>
                    <li>Let <var>stream</var> be the RTCQuicWritableStream.</li>
                    <li>Set <var>stream</var>'s <a>[[\Writable]]</a> slot to
                    <code>false</code>.</li>
                    <li>Clear the <var>stream</var>'s write buffer.</li>
                    <li>Remove the <var>stream</var> from the <var>transport</var>'s
                    <a>[[\QuicTransportWritableStreams]]</a> internal slot.
                  </ol>
                </ol>
              </td>
            </tr>
            <tr>
              <td><dfn><code id=
              "idl-def-RTCQuicTransportState.failed">failed</code></dfn></td>
              <td>
                <p>The QUIC connection has been closed as the result of an error (such as
                receipt of an error alert or a failure to validate the remote
                fingerprint). When the <code><a>RTCQuicTransport</a></code>'s
                internal <a>[[\QuicTransportState]]</a> slot transitions to
                <code>failed</code> the user agent <em class="rfc2119" title="MUST">MUST</em>
                run the following steps:</p>
                <ol>
                  <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>.
                  <li>For each RTCQuicReadableStream in <var>transport</var>'s
                  <a>[[\QuicTransportReadableStreams]]</a> internal slot run the
                  following:</li>
                  <ol>
                    <li>Let <var>stream</var> be the RTCQuicReadableStream.</li>
                    <li>Set <var>stream</var>'s <a>[[\Readable]]</a> slot to
                    <code>false</code>.</li>
                    <li>Clear the <var>stream</var>'s read buffer.</li>
                    <li>Remove the <var>stream</var> from the <var>transport</var>'s
                    <a>[[\QuicTransportReadableStreams]]</a> internal slot.
                  </ol>
                  <li>For each RTCQuicWritableStream in <var>transport</var>'s
                  <a>[[\QuicTransportWritableStreams]]</a> internal slot run the
                  following:</li>
                  <ol>
                    <li>Let <var>stream</var> be the RTCQuicWritableStream.</li>
                    <li>Set <var>stream</var>'s <a>[[\Writable]]</a> slot to
                    <code>false</code>.</li>
                    <li>Clear the <var>stream</var>'s write buffer.</li>
                    <li>Remove the <var>stream</var> from the <var>transport</var>'s
                    <a>[[\QuicTransportWritableStreams]]</a> internal slot.
                  </ol>
                </ol>
              </td>
            </tr>
          </tbody>
        </table>
      </div>
    </section>
  </section>
  <section id="quicstream*">
    <h2><dfn>QUIC Stream API</dfn></h2>
    <p>The <code>QUIC Stream API</code> includes information relating
    to a QUIC stream. </p>
    <section id="rtcquicstream-overview*">
      <h3>Overview</h3>
      <p><code><a>RTCQuicBidirectionalStream</a></code>, <code><a>RTCQuicSendStream</a></code>,
      and <code><a>RTCQuicReceiveStream</a></code> instances are associated to
      a <code><a>RTCQuicTransport</a></code> instance.</p>
    </section>
    <section id="rtcquicstream-operation*">
      <h3>Operation</h3>
      <p>A <code><a>RTCQuicBidirectionalStream</a></code> can be created in the
      following ways:</p>
      <ol>
        <li>Using the <code><a>RTCQuicTransport</a>.createBidirectionalStream</code></li>
        <li>Getting a <code><a>bidirectionalstreamwithdata</a></code> event on the
        <code><a>RTCQuicTransport</a></code></li>
      </ol>
      <p>A <code><a>RTCQuicSendStream</a></code> can be created in the following
      ways:</p>
      <ol>
        <li>Using the <code><a>RTCQuicTransport</a>.createSendStream</code></li>
      </ol>
      <p>A <code><a>RTCQuicReceiveStream</a></code> can be created in the following
      ways:</p>
      <ol>
        <li>Getting a <code><a>receivestreamwithdata</a></code> event on the
        <code><a>RTCQuicTransport</a></code></li>
      </ol>
    </section>
    <section id="rtcquicwritablestream-interface-mixin-definition*">
      <h3>Interface Mixin <dfn>RTCQuicWritableStream</dfn></h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
        interface mixin RTCQuicWritableStream {
            readonly attribute boolean writable;
            readonly attribute unsigned long writeBufferedAmount;
            readonly attribute Promise&lt;RTCQuicStreamAbortInfo&gt; writingAborted;
            void write (RTCQuicStreamWriteParameters data);
            void abortWriting (RTCQuicStreamAbortInfo abortInfo);
            Promise&lt;void&gt; waitForWriteBufferedAmountBelow(unsigned long threshold);
        };
        </pre>
        <section>
          <h2>Overview</h2>
          <p>The <code><a>RTCQuicWritableStream</a></code> will initialize with
          the following:</p>
          <ol>
            <li>Let <var>stream</var> be the <code><a>RTCQuicWritableStream</a></code>.</li>
            <li>Let <var>stream</var> have a <dfn>[[\Writable]]</dfn> internal
            slot initialized to <code>true</code>.</li>
            <li>Let <var>stream</var> have a <dfn>[[\WriteBufferedAmount]]</dfn> internal
            slot initialized to zero.</li>
          </ol>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicWritableStream" data-dfn-for="RTCQuicWritableStream" class=
          "attributes">
            <dt><code>writable</code> of type <span class=idlAttriType"><a>boolean</a>
            readonly</dt>
            <dd>
              <p>The <dfn id="dom-rtcquicwritablestream-writable"><code>writable</code></dfn>
              attribute represents whether data can be written to the
              <code><a>RTCQuicWritableStream</a></code>. On getting it
              <em class="rfc2119" title="MUST">MUST</em> return the value of the
              <a>[[\Writable]]</a> slot.</p>
            </dd>
            <dt><code>writeBufferedAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-rtcquicwritablestream-writable"><code>writeBufferedAmount</code></dfn>
              attribute represents the number of bytes of application data
              that have been queued using <code>write</code> but that, as of the last
              time the event loop started executing a task, had not yet been transmitted
              to the network. This includes any data sent during the execution of the
              current task, regardless of whether the <a>user agent</a> is able to
              transmit text asynchronously with script execution. This does not
              include framing overhead incurred by the protocol, or buffering done
              by the operating system or network hardware. On getting, it
              <em class="rfc2119" title="MUST">MUST</em> return the value of the
              RTCQuicWritableStream's <a>[[\WriteBufferedAmount]]</a> internal slot.
            </dd>
            <dt><code>writingAborted</code> of type <span class=idlAttriType"><a>RTCQuicStreamAbortInfo</a>
            readonly</dt>
            <dd>
              <p>The <dfn id="dom-rtcquicwritablestream-writingAborted"><code>writingAborted</code></dfn>
              attribute represents a promise that <a>resolves</a> when the
              STOP_SENDING frame is received from the <code><a>RTCQuicReadableStream</a></code>.
              When the <var>stream</var> receives a STOP_SENDING frame from its corresponding
              <code><a>RTCQuicReadableStream</a></code>, the <a>user agent</a>
              <em class="rfc2119" title="MUST">MUST</em> run the following:
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicWritableStream</a></code> object.
                <li>Set <var>stream</var>'s <a>[[\Writable]]</a> slot to <code>false</code>.</li>
                <li>Clear the <var>stream</var>'s write buffer.</li>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>,
                which the <var>stream</var> was created from.
                <li>Remove the <var>stream</var> from the <var>transport</var>'s
                <a>[[\QuicTransportWritableStreams]]</a> internal slot.</li>
                <li><a>resolve</a> the promise with the resulting
                <code><a>RTCQuicStreamAbortInfo</a></code> with the <code>errorCode</code>
                set to the value from the STOP_SENDING frame.</li>
              </ol>
            </dd>
          </dl>
       </section>
       <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicWritableStream" data-dfn-for="RTCQuicWritableStream" class=
          "methods">
            <dt><dfn><code>write</code></dfn></dt>
            <dd>
              <p>Writes data to the stream. When the remote <code><a>RTCQuicTransport</a></code>
              receives the STREAM frame from this stream for the first time, it will trigger the
              creation of the corresponding remote stream. When the <code>write</code> method is
              called, the <a>user agent</a> <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
               <li>Let <var>data</var> be the first argument.</li>
               <li>Let <var>stream</var> be the RTCQuicWritableStream
               object on which <var>data</var> is to be sent.</li>
               <li>if length of <var>data</var>.data is 0 and <var>data</var>.finished is
               <code>false</code>, <a>throw</a> a <code>NotSupportedError</code> and abort
               these steps.</li>
               <li>If <var>stream</var>'s <a>[[\Writable]]</a> slot is <code>false</code>,
               <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
               <li>Increase the value of <var>stream</var>'s
               <a>[[\WriteBufferedAmount]]</a> slot by the length of
               <var>data</var>.data in bytes.</li>
               <li>Queue <var>data</var>.data for transmission on <var>stream</var>'s
               underlying data transport.</li>
               <li>if <var>data</var>.finish is set to <code>true</code>, run the
               following:</li>
               <ol>
                 <li>Queue a STREAM frame with the FIN bit set.</li>
                 <li>Set <var>stream</var>'s <a>[[\Writable]]</a> slot to
                 <code>false</code>.</li>
                 <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>,
                 which the <var>stream</var> was created from.</li>
                 <li>Remove the <var>stream</var> from the <var>transport</var>'s
                 <a>[[\QuicTransportWritableStreams]]</a> internal slot.</li>
               </ol>
               <div class="note">The actual transmission of data occurs in
               parallel. If sending data leads to a QUIC-level error, the
               application will be notified asynchronously through the
               <code><a>RTCQuicTransport</a></code>'s <code><a>onerror</a></code>
               EventHandler.</div>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>RTCQuicStreamWriteParameters</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>abortWriting</code></dfn></dt>
            <dd>
              <p>A hard shutdown of the RTCQuicWritable stream. It may be called
              regardless of whether the RTCQuicWritableStream object
              was created by the local or remote peer. When the <code>abortWriting()</code>
              method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the RTCQuicWritableStream object
                which is about to abort writing.</li>
                <li>If <var>stream</var>'s <a>[[\Writable]]</a> slot is <code>false</code>,
                <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
                <li>Set <var>stream</var>'s <a>[[\Writable]]</a> slot to <code>false</code>.</li>
                <li>Clear the <var>stream</var>'s write buffer.</li>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>,
                which the <var>stream</var> was created from.</li>
                <li>Remove the <var>stream</var> from the <var>transport</var>'s
                <a>[[\QuicTransportWritableStreams]]</a> internal slot.</li>
                <li>Let <var>abortInfo</var> be the first argument.</li>
                <li>Start the closing procedure by sending a RST_STREAM frame with its error
                code set to the value of <var>abortInfo</var>.errorCode.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">abortInfo</td>
                    <td class="prmType"><code>RTCQuicStreamAbortInfo</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
            <dt><dfn><code>waitForWriteBufferedAmountBelow</code></dfn></dt>
            <dd>
              <p><code>waitForWriteBufferedAmountBelow</code> <a>resolves</a> the promise when
              the data queued in the write buffer falls below the given threshold.
              If <code>waitForWriteBufferedAmountBelow</code>
              is called multiple times, multiple promises could be resolved when the
              write buffer falls below the threshold for each promise. The Promise will
              be <a>rejected</a> with a newly created <code>InvalidStateError</code> if the
              <var>stream</var>'s <a>[[\Writable]]</a> slot transitions from true to false
              and the promise isn't <a>settled</a>. When the <code>waitForWriteBufferedAmountBelow</code> method
              is called, the <a>user agent</a> <em class="rfc2119" title="MUST">MUST</em> run
              the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the RTCQuicWritableStream
                object on which <code>waitForWriteBufferedAmountBelow</code> was invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>If <var>stream</var>'s <a>[[\Writable]]</a> slot is
                <code>false</code>, <a>reject</a> <var>p</var> with a
                newly created <code>InvalidStateError</code> and abort
                these steps.</li>
                <li>Let <var>threshold</var> be the first argument.</li>
                <li>When <var>stream</var>'s <a>[[\WriteBufferedAmount]]]</a> slot decreases
                from above <var>threshold</var> to less than or equal to it,
                <a>resolve</a> <var>p</var> with <code>undefined</code>.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">threshold</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
        </dl>
      </section>
      </div>
    </section>
    <section id="rtcquicreadablestream-interface-mixin-definition*">
      <h3>Interface Mixin <dfn>RTCQuicReadableStream</dfn></h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
        interface mixin RTCQuicReadableStream {
            readonly attribute boolean readable;
            readonly attribute unsigned long readableAmount;
            readonly attribute Promise&lt;RTCQuicStreamAbortInfo&gt; readingAborted;
            RTCQuicStreamReadResult readInto (Uint8Array data);
            void abortReading (RTCQuicStreamAbortInfo abortInfo);
            Promise&lt;void&gt;   waitForReadable(unsigned long amount);
        };
        </pre>
        <section>
          <h2>Overview</h2>
          <p>The <code><a>RTCQuicReadableStream</a></code> will initialize with
          the following:</p>
          <ol>
            <li>Let <var>stream</var> be the <code><a>RTCQuicReadableStream</a></code>.</li>
            <li>Let <var>stream</var> have a <dfn>[[\Readable]]</dfn> internal
            slot initialized to <code>true</code>.</li>
            <li>Let <var>stream</var> have a <dfn>[[\ReadableAmount]]</dfn> internal
            slot initialized to zero.</li>
          </ol>
        </section>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicReadableStream" data-dfn-for="RTCQuicReadableStream" class=
          "attributes">
            <dt><code>readable</code> of type <span class="idlAttrType"><a>boolean</a></span>,
            readonly</dt>
            <dd>
              <p>The <dfn id="dom-rtcquicreadablestream-readableamount"><code>readable</code></dfn>
              attribute represents whether data can be read from the <code><a>RTCQuicReadableStream</a></code>.
              On getting, it <em class="rfc2119" title="MUST">MUST</em> return the value of the
              RTCQuicReadableStream's <a>[[\Readable]]</a> slot.
            </dd>
            <dt><code>readableAmount</code> of type <span class="idlAttrType"><a>unsigned
            long</a></span>, readonly</dt>
            <dd>
              <p>The <dfn id="dom-rtcquicreadablestream-readableamount"><code>readableAmount</code></dfn>
              attribute represents the number of bytes buffered for access by
              <code>readInto</code> but that, as of the last time the event loop
              started executing a task, had not yet been read. This does not include
              framing overhead incurred by the protocol, or buffers associated with
              the network hardware. On getting, it <em class="rfc2119" title="MUST">MUST</em>
              return the value of the RTCQuicReadableStream's
              <a>[[\ReadableAmount]]</a> internal slot.</p>
            </dd>
            <dt><code>readingAborted</code> of type <span class=idlAttriType"><a>RTCQuicStreamAbortInfo</a>
            readonly</dt>
            <dd>
              <p>The <dfn id="dom-rtcquicreadablestream-readingAborted"><code>readingAborted</code></dfn>
              attribute represents a promise that <a>resolves</a> when the
              RST_STREAM frame is received from the <code><a>RTCQuicWritableStream</a></code>.
              When the <var>stream</var> receives a RST_STREAM frame from its corresponding
              <code><a>RTCQuicWritableStream</a></code>, the <a>user agent</a>
              <em class="rfc2119" title="MUST">MUST</em> run the following:
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicReadableStream</a></code>
                object</li>
                <li>Set <var>stream</var>'s <a>[[\Readable]]</a> slot to <code>false</code>.</li>
                <li>Clear the <var>stream</var>'s read buffer.</li>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>,
                which the <var>stream</var> was created from.
                <li>Remove the <var>stream</var> from the <var>transport</var>'s
                <a>[[\QuicTransportReadableStreams]]</a> internal slot.</li>
                <li><a>resolve</a> the promise with the resulting
                <code><a>RTCQuicStreamAbortInfo</a></code> with <code>errorCode</code>
                set to the value of the errror code from the RST_STREAM frame.</li>
              </ol>
            </dd>
          </dl>
       </section>
       <section>
          <h2>Methods</h2>
          <dl data-link-for="RTCQuicReadableStream" data-dfn-for="RTCQuicReadableStream" class=
          "methods">
            <dt><dfn><code>readInto</code></dfn></dt>
            <dd>
              <p>Reads from RTCQuicReadableStream into the buffer specified
              by the first argument and returns <code><a>RTCQuicStreamReadResult</a></code>.
              When the <code>readInto</code> method is called, the user agent
              <em class="rfc2119" title="MUST">MUST</em> run the following steps:</p>
              <ol>
               <li>Let <var>stream</var> be the RTCQuicReadableStream object
               on which <code>readInto</code> is invoked.</li>
               <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is <code>false</code>,
               <a>throw</a> an <code>InvalidStateError</code>, then abort these steps.</li>
               <li>Let <var>data</var> be the first argument.</li>
               <li>Let <var>result</var> be the <code><a>RTCQuicStreamReadResult</a></code>
               to be returned.</li>
               <li>If <var>stream</var> has <a>finished reading</a>, return
               <var>result</var> with <code>amount</code> set to 0 and <code>finished</code> set to
               <code>true</code> and abort these steps.</li>
               <li>Transfer data from the read buffer into <var>data</var>.</li>
               <li>Decrease the value of <var>stream</var>'s <a>[[\ReadableAmount]]</a>
               slot by the length of <var>data</var> in bytes.</li>
               <li>Set <var>result</var>'s <code>amount</code> to the size of
               <var>data</var> in bytes.</li>
               <li>If the <var>data</var> includes up to the FIN bit being read, then
               run the following steps:</li>
               <ol>
                 <li>Set <var>result</var>'s <code>finished</code> to <code>true</code>.</li>
                 <li>Set the <var>stream</var>'s <a>[[\Readable]]</a> slot to
                 <code>false</code>.</li>
                 <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>,
                 which the <var>stream</var> was created from.
                 <li>Remove the <var>stream</var> from the <var>transport</var>'s
                 <a>[[\QuicTransportReadableStreams]]</a> internal slot.</li>
               </ol>
               <li>Else, set <var>result</var>'s <code>finished</code> to false.</li>
               <li>Return <var>result</var>.
              </ol>
              <table class="parameters">
               <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">data</td>
                    <td class="prmType"><code>Uint8Array</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code><a>RTCQuicStreamReadResult</a></code>
              </div>
            </dd>
            <dt><dfn><code>abortReading</code></dfn></dt>
            <dd>
              <p>A hard shutdown of the RTCQuicReadableStream. It may be called
              regardless of whether the RTCQuicReadableStream object
              was created by the local or remote peer. When the <code>abortReading()</code>
              method is called, the user agent <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the RTCQuicReadableStream object
                which is about to abort reading.</li>
                <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is <code>false</code>,
                <a>throw</a> an <code>InvalidStateError</code> and abort these steps.</li>
                <li>Set <var>stream</var>'s <a>[[\Readable]]</a> slot to <code>false</code>.</li>
                <li>Clear the <var>stream</var>'s read buffer.</li>
                <li>Let <var>transport</var> be the <code><a>RTCQuicTransport</a></code>,
                which the <var>stream</var> was created from.
                <li>Remove the <var>stream</var> from the <var>transport</var>'s
                <a>[[\QuicTransportReadableStreams]]</a> internal slot.</li>
                <li>Let <var>abortInfo</var> be the first argument.</li>
                <li>Start the closing procedure by sending a STOP_SENDING frame with its error
                code set to the value of <var>abortInfo</var>.errorCode.</li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">abortInfo</td>
                    <td class="prmType"><code>RTCQuicStreamAbortInfo</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>void</code>
              </div>
            </dd>
           <dt><dfn><code>waitForReadable</code></dfn></dt>
            <dd>
              <p><code>waitForReadable</code> waits for data to become available, or
              for the <code><a>RTCQuicReadableStream</a></code> to be finished reading.  It
              <a>resolves</a> the promise when the data queued in the read buffer
              increases above the amount provided as an argument or when a STREAM frame
              with the FIN bit set has been received. If <code>waitForReadable</code>
              is called multiple times, multiple promises could be resolved.
              The Promise will be <a>rejected</a> with a newly created
              <code>InvalidStateError</code> if the <var>stream</var>'s
              <a>[[\Readable]]</a> slot transitions from true to false and the promise
              isn't <a>settled</a>. When the <code>waitForReadable</code> method is
              called, the <a>user agent</a> <em class="rfc2119" title="MUST">MUST</em>
              run the following steps:</p>
              <ol>
                <li>Let <var>stream</var> be the <code><a>RTCQuicReadableStream</a></code>
                on which <code>waitForReadable</code> is invoked.</li>
                <li>Let <var>p</var> be a new promise.</li>
                <li>If <var>stream</var>'s <a>[[\Readable]]</a> slot is
                <code>false</code>, <a>reject</a> <var>p</var> with a
                newly created <code>InvalidStateError</code> and abort
                these steps.</li>
                <li>Let <var>amount</var> be the first argument.</li>
                <li><a>Resolve</a> <var>p</var> with <code>undefined</code> when
                any of the following conditions are met:
                  <ol>
                    <li>The <a>[[\ReadableAmount]]</a> increases from
                    below the value of <var>amount</var> to greater than or equal
                    to it.</li>
                    <li><var>stream</var> receives a STREAM frame with the
                    FIN bit set and <a>[[\ReadableAmount]]</a> is less than
                    <var>amount</var>.</li>
                  </ol>
                </li>
              </ol>
              <table class="parameters">
                <tbody>
                  <tr>
                    <th>Parameter</th>
                    <th>Type</th>
                    <th>Nullable</th>
                    <th>Optional</th>
                    <th>Description</th>
                  </tr>
                  <tr>
                    <td class="prmName">amount</td>
                    <td class="prmType"><code>unsigned long</code></td>
                    <td class="prmNullFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmOptFalse"><span role="img" aria-label=
                    "False">&#10008;</span></td>
                    <td class="prmDesc"></td>
                  </tr>
                </tbody>
              </table>
              <div>
                <em>Return type:</em> <code>Promise&lt;void&gt;</code>
              </div>
            </dd>
        </dl>
      </section>
      </div>
    </section>
    <section id="rtcquicstream-interface-definition*">
      <h3>Interface <dfn>RTCQuicStream</dfn></h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
        interface RTCQuicStream {
            readonly attribute unsigned long long streamId;
            readonly attribute RTCQuicTransport transport;
        };
        </pre>
        <section>
          <h2>Attributes</h2>
          <dl data-link-for="RTCQuicStream" data-dfn-for="RTCQuicStream" class=
          "attributes">
            <dt><dfn><code>streamId</code></dfn> of type <span class=
            "idlAttrType"><a>unsigned long long</a></span>, readonly</dt>
            <dd>
              <p>The readonly attribute referring to the ID of the
              <code><a>RTCQuicStream</a></code> object.</p>
            </dd>
            <dt><dfn><code>transport</code></dfn> of type <span class=
            "idlAttrType"><a>RTCQuicTransport</a></span>, readonly</dt>
            <dd>
              <p>The readonly attribute referring to the related <code><a>RTCQuicTransport</a></code> object.</p>
            </dd>
          </dl>
       </section>
      </div>
    </section>
    <section id="rtcquicbidirectionalstream-interface-definition*">
      <h3>Interface <dfn>RTCQuicBidirectionalStream</dfn></h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
        interface RTCQuicBidirectionalStream : RTCQuicStream {
        };
        RTCQuicBidirectionalStream includes RTCQuicWritableStream;
        RTCQuicBidirectionalStream includes RTCQuicReadableStream;
        </pre>
      </div>
    </section>
    <section id="rtcquicsendstream-interface-definition*">
      <h3>Interface <dfn>RTCQuicSendStream</dfn></h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
        interface RTCQuicSendStream : RTCQuicStream {
        };
        RTCQuicSendStream includes RTCQuicWritableStream;
        </pre>
      </div>
    </section>
    <section id="rtcquicreceivestream-interface-definition*">
      <h3>Interface <dfn>RTCQuicReceiveStream</dfn></h3>
      <div>
        <pre class="idl">
        [ Exposed=Window ]
        interface RTCQuicReceiveStream : RTCQuicStream {
        };
        RTCQuicReceiveStream includes RTCQuicReadableStream;
        </pre>
      </div>
    </section>
    <section id="rtcquicstreamwriteparameters*">
      <h3><dfn>RTCQuicStreamWriteParameters</dfn> Dictionary</h3>
      <p>The <code>RTCQuicStreamWriteParameters</code> dictionary includes information
      relating to the data to be written with <code><a>RTCQuicWritableStream</a>.write</code>.</p>
      <div>
        <pre class="idl">dictionary RTCQuicStreamWriteParameters {
             Uint8Array data;
             boolean finished = false;
        };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCQuicStreamWriteParameters</a> Members</h2>
          <dl data-link-for="RTCQuicStreamWriteParameters" data-dfn-for="RTCQuicStreamWriteParameters" class=
          "dictionary-members">
            <dt><dfn><code>data</code></dfn> of type <span class=
            "idlMemberType"><a>Uint8Array</a></span>.</dt>
            <dd>
              <p>The data to be written.</p>
            </dd>
            <dt><dfn><code>finished</code></dfn> of type <span class=
            "idlMemberType">boolean</span>.</dt>
            <dd>
              <p>Set to <code>true</code> if this is the last data to be written.
              This will result in a STREAM frame with the FIN bit set.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicstreamresult*">
      <h3><dfn>RTCQuicStreamReadResult</dfn> Dictionary</h3>
      <p>The <code>RTCQuicStreamReadResult</code> dictionary includes information
      relating to the result returned from <code>readInto</code>.</p>
      <div>
        <pre class="idl">dictionary RTCQuicStreamReadResult {
             unsigned long amount;
             boolean finished = false;
        };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCQuicStreamReadResult</a> Members</h2>
          <dl data-link-for="RTCQuicStreamReadResult" data-dfn-for="RTCQuicStreamReadResult" class=
          "dictionary-members">
            <dt><dfn><code>amount</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned long</a></span>.</dt>
            <dd>
              <p>The amount of data read in bytes.</p>
            </dd>
            <dt><dfn><code>finished</code></dfn> of type <span class=
            "idlMemberType">boolean</span>.</dt>
            <dd>
              <p>Set to <code>true</code> if the RTCQuicReadableStream has
              <a>finished reading</a>.</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
    <section id="rtcquicstreamabortinfo*">
      <h3><dfn>RTCQuicStreamAbortInfo</dfn> Dictionary</h3>
      <p>The <code>RTCQuicStreamAbortInfo</code> dictionary includes information
      relating to the error code for aborting a QUIC stream. This could be used either
      in a RST_STREAM frame or STOP_SENDING frame.</p>
      <div>
        <pre class="idl">dictionary RTCQuicStreamAbortInfo {
             unsigned short errorCode = 0;
        };
        </pre>
        <section>
          <h2>Dictionary <a class="idlType">RTCQuicStreamAbortInfo</a> Members</h2>
          <dl data-link-for="RTCQuicStreamAbortInfo" data-dfn-for="RTCQuicStreamAbortInfo" class=
          "dictionary-members">
            <dt><dfn><code>errorCode</code></dfn> of type <span class=
            "idlMemberType"><a>unsigned short</a></span>.</dt>
            <dd>
              <p>The error code used in the RST_STREAM or STOP_SENDING frame.
              The default value of 0 means "STOPPING."</p>
            </dd>
          </dl>
        </section>
      </div>
    </section>
  </section>
    <section id="privacy-security">
    <h2>Privacy and Security Considerations</h2>
    <p>This section is non-normative; it specifies no new behaviour, but
    instead summarizes information already present in other parts of the
    specification. The overall security considerations of the
    APIs and protocols used in WebRTC are described in
    [[RTCWEB-SECURITY-ARCH]].</p>
    <section>
      <h2>Impact on same origin policy</h2>
      <p>The QUIC API enables data to be communicated between
      browsers and other devices, including other browsers.</p>
      <p>This means that data can be shared between applications
      running in different browsers, or between an application running in the
      same browser and something that is not a browser.  This is an extension
      to the Web model which has had barriers against sending data
      between entities with different origins.</p>
      <p>This specification provides no user prompts or chrome indicators
      for communication; it assumes that once the Web page has been allowed to
      access data, it is free to share that data with other entities as it
      chooses. Peer-to-peer exchanges of data via QUIC can therefore
      occur without any user explicit consent or involvement.</p>
    </section>
    <section>
      <h2>Impact on local network</h2>
      <p>Since the browser is an active platform executing in a trusted network
      environment (inside the firewall), it is important to limit the damage
      that the browser can do to other elements on the local network, and it is
      important to protect data from interception, manipulation and
      modification by untrusted participants.</p>
      <p>Mitigations include:</p>
      <ul>
        <li>An UA will always request permission from the correspondent UA to
        communicate using ICE. This ensures that the UA can only send to
        partners who you have shared credentials with.</li>
        <li>An UA will always request ongoing permission to continue sending
        using ICE consent [[!RFC7675]]. This enables a receiver to withdraw
        consent to receive.</li>
        <li>An UA will always encrypt data, with strong per-session keying.</li>
        <li>An UA will always use congestion control. This ensures that QUIC
        cannot be used to flood the network.</li>
      </ul>
      <p>These measures are specified in the relevant IETF documents.</p>
    </section>
    <section>
      <h2>Confidentiality of Communications</h2>
      <p>The fact that communication is taking place cannot be hidden from
      adversaries that can observe the network, so this has to be regarded as
      public information.</p>
      <p>Since the QUIC protocol utilizes a cryptographic negotiation based on
      TLS 1.3 [[TLS13]] in order to encrypt communications, it provides confidentiality.</p>
    </section>
    <section>
      <h2>Persistent information</h2>
      <p>Utilizing the <code>generateCertificate</code> API in [[!WEBRTC]], it is possible to
      generate and store certificates that can subsequently be reused in constructing
      <code><a>RTCQuicTransport</a></code> objects.  These persistent certificates
      can therefore be used to identify a user.</p>
    </section>
  </section>
  <section class="informative">
    <h2>Event summary</h2>
    <p>The following events fire on <code><a>RTCQuicTransport</a></code> objects:</p>
    <table style="border-width:0; width:60%" border="1">
      <tbody>
        <tr>
          <th>Event name</th>
          <th>Interface</th>
          <th>Fired when...</th>
        </tr>
      </tbody>
      <tbody>
        <tr>
          <td><code>error</code></td>
          <td><code><a>ErrorEvent</a></code></td>
          <td>The <code><a>RTCQuicTransport</a></code> object has encountered an error.</td>
        </tr>
        <tr>
          <td><code>statechange</code></td>
          <td><code><a>Event</a></code></td>
          <td>The <code><a>RTCQuicTransportState</a></code> changed.</td>
        </tr>
        <tr>
          <td><dfn><code>receivestreamwithdata</code></dfn></td>
          <td><code><a>ReceiveStreamWithDataEvent</a></code></td>
          <td>A new <code><a>RTCQuicReceiveStream</a></code> is dispatched to the
          script in response to the remote peer creating a send only QUIC stream and
          sending data on it. Prior to <code><a>receivestreamwithdata</a></code>
          firing, the <code><a>RTCQuicReceiveStream</a></code> is added to
          <code><a>RTCQuicTransport</a></code>'s<a>[[\QuicTransportReadableStreams]]</a>
          internal slot.</td>
        </tr>
        <tr>
          <td><dfn><code>bidirectionalstreamwithdata</code></dfn></td>
          <td><code><a>BidirectionalStreamWithDataEvent</a></code></td>
          <td>A new <code><a>RTCQuicBidirectionalStream</a></code> is dispatched to the
          script in response to the remote peer creating a bidirectional QUIC stream and
          sending data on it. Prior to <code><a>bidirectionalstreamwithdata</a></code>
          firing, the <code><a>RTCQuicBidirectionalStream</a></code> is added to both the
          <code><a>RTCQuicTransport</a></code>'s <a>[[\QuicTransportReadableStreams]]</a>
          and <a>[[\QuicTransportWritableStreams]]</a> internal slot.</td>
        </tr>
      </tbody>
    </table>
  </section>
 <section id="examples*">
    <h2>Examples</h2>
      <pre class="example highlight">
      </pre>
       <section class="informative" id="rtcquicexample*">
      <h2>Examples</h2>
      <pre class="example highlight">
function initiate(mySignaller) {
  // Prepare the ICE gatherer
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  // Handle state changes
  iceGatherer.onstatechange = function(event) {
    myIceGathererStateChange("iceGatherer", event.state);
  };
  // Handle errors
  iceGatherer.onerror = errorHandler;
  // Prepare to signal local candidates
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

  // Start gathering
  iceGatherer.gather();
  // Create ICE transport
  var ice = new RTCIceTransport(iceGatherer);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

  // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create DTLS and QUIC transport
  var dtls = new RTCDtlsTransport(ice, certs);
  var quic = new RTCQuicTransport(ice, certs);

  mySignaller.sendInitiate({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters(),
    quic: quic.getLocalParameters(),
    // ... marshall RtpSender/RtpReceiver capabilities as illustrated in Section 6.5 Example 9.
  }, function(remote) {
    // Start the ICE, DTLS and QUIC transports
    ice.start(iceGatherer, remote.ice, RTCIceRole.controlling);
    dtls.start(remote.dtls);
    quic.start(remote.quic);
    // ... configure RtpSender/RtpReceiver objects as illustrated in Section 6.5 Example 9.
  });
}
</pre>
<pre class="example highlight">
// This is an example of how to answer
// Include some helper functions
import {trace, errorHandler, mySendLocalCandidate, myIceGathererStateChange,
  myIceTransportStateChange, myDtlsTransportStateChange} from 'helper';

function accept(mySignaller, remote) {
  var gatherOptions = {
    gatherPolicy: "all",
    iceServers: [
      { urls: "stun:stun1.example.net" },
      { urls: "turn:turn.example.org", username: "user", credential: "myPassword",
        credentialType: "password" }
     ]
  };
  var iceGatherer = new RTCIceGatherer(gatherOptions);
  // Handle state changes
  iceGatherer.onstatechange = function(event) {
    myIceGathererStateChange("iceGatherer", event.state);
  };
  // Handle errors
  iceGatherer.onerror = errorHandler;
  // Prepare to signal local candidates
  iceGatherer.onlocalcandidate = function(event) {
    mySignaller.mySendLocalCandidate(event.candidate);
  };

   // Start gathering
  iceGatherer.gather();
  // Create ICE transport
  var ice = new RTCIceTransport(iceGatherer);
  // Prepare to handle remote ICE candidates
  mySignaller.onRemoteCandidate = function(remote) {
    ice.addRemoteCandidate(remote.candidate);
  };

   // Create the DTLS certificate
  var certs;
  var keygenAlgorithm = { name: "ECDSA", namedCurve: "P-256" };
  RTCCertificate.generateCertificate(keygenAlgorithm).then(function(certificate){
    certs[0] = certificate;
  }, function(){
    trace('Certificate could not be created');
  });

  // Create DTLS and SCTP transport
  var dtls = new RTCDtlsTransport(ice, certs);
  var quic = new RTCQuicTransport(ice, certs);

  mySignaller.sendAccept({
    ice: iceGatherer.getLocalParameters(),
    dtls: dtls.getLocalParameters(),
    quic: quic.getLocalParameters(),
    // ... marshall RtpSender/RtpReceiver capabilities as illustrated in Section 6.5 Example 9.
  });

   // Start the ICE, DTLS and SCTP transports
  ice.start(iceGatherer, remote.ice, RTCIceRole.controlled);
  dtls.start(remote.dtls);
  // Start the QuicTransport
  quic.start(remote.quic);

  // ... configure RtpSender/RtpReceiver objects as illustrated in Section 6.5 Example 9.

}
                </pre>
    </section>  
 </section>
 <section id="change-log*">
    <h2>Change Log</h2>
    <p>This section will be removed before publication.</p>
 </section>
 <section class="appendix">
    <h2>Acknowledgements</h2>
    <p>The editors wish to thank the Working Group chairs and Team Contact,
    Harald Alvestrand, Stefan H&aring;kansson, Bernard Aboba and Dominique
    Haza&euml;l-Massieux, for their support. Contributions to this
    specification were provided by Robin Raymond.</p>
    <p>The <code><a>RTCQuicTransport</a></code> and <code>RTCQuicStream</code> objects
    were initially described in the <a href="https://www.w3.org/community/ortc/">W3C ORTC CG</a>,
    and have been adapted for use in this specification.</p>
 </section>
</body>
</html>
